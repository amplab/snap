using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Threading;
using ASELib;
using System.Runtime.InteropServices;
using System.Diagnostics;

//
// Takes SAM lines generated by SNAP aligning the output of GenerateReadsForRepetitiveRegionDetection and figures out how far the best and second
// best alignments are from one another in edit distance space.
//

namespace MeasureSecondaryAlignmentDistributuion
{
    internal class Program
    {

        class State
        {
            public long nUnmapped = 0;
            public Dictionary<int, long> countByDistance = new Dictionary<int, long>();

            public Dictionary<string, ASETools.SAMLine> unmatchedReads = new Dictionary<string, ASETools.SAMLine>();    // Maps read name (which is the generated coordinate) to the line (either primary or secondary, whichever comes first)

            public void mergeFrom(State peer)
            {
                nUnmapped += peer.nUnmapped;

                foreach (var count in peer.countByDistance.Select(_ => _.Key))
                {
                    if (!countByDistance.ContainsKey(count))
                    {
                        countByDistance.Add(count, peer.countByDistance[count]);
                    }
                    else
                    {
                        countByDistance[count] += peer.countByDistance[count];
                    }
                }

                foreach (var unmappedRead in peer.unmatchedReads.Select(_ => _.Value))
                {
                    handleLine(unmappedRead);
                }
            } // mergeFrom

            public void handleLine(ASETools.SAMLine line)
            {
                if (line.isUnmapped())
                {
                    nUnmapped++;
                }
                else if (!line.NMKnown())
                {
                    Console.WriteLine("Mapped line with unknown NM: " + line.line + ".  Ignoring.");
                }
                else if (unmatchedReads.ContainsKey(line.qname))
                {
                    var difference = Math.Abs(line.NM() - unmatchedReads[line.qname].NM());
                    if (!countByDistance.ContainsKey(difference))
                    {
                        countByDistance.Add(difference, 1);
                    }
                    else
                    {
                        countByDistance[difference]++;
                    }
                    unmatchedReads.Remove(line.qname);
                }
                else
                {
                    unmatchedReads.Add(line.qname, line);
                }
            } // handleLine
        } // State

        static State globalState = new State();

        static void ProcessThread(ASETools.ThrottledParallelQueue<string> queue)
        {
            var state = new State();

            string rawLine;

            while (queue.Dequeue(out rawLine))
            {
                if (rawLine.StartsWith("@"))
                {
                    continue;
                }

                var line = new ASETools.SAMLine(rawLine);

                state.handleLine(line);
            } // while we have a line

            lock (globalState)
            {
                globalState.mergeFrom(state);
            } // lock
        } // ProcessThread


        static void Main(string[] args)
        {

            var timer = new Stopwatch();
            timer.Start();

            if (args.Count() != 2)
            {
                Console.WriteLine("usage: MeasureSecondaryAlignmentDistributuion input.SAM output");
                return;
            }

            var inputFile = ASETools.CreateStreamReaderWithRetry(args[0]); 
            if (null == inputFile)
            {
                Console.WriteLine("Unable to open input file " + args[0]);
                return;
            }

            var outputFile = ASETools.CreateStreamWriterWithRetry(args[1]);
            if (null == outputFile)
            {
                Console.WriteLine("Unable to open output file " + args[1]);
                return;
            }

            ASETools.ThrottledParallelQueue<string> queue = new ASETools.ThrottledParallelQueue<string>(100000, 1);

            var workerThreads = new List<Thread>();
            for (int i = 0; i < Math.Min(1, Environment.ProcessorCount - 1); i++)
            {
                workerThreads.Add(new Thread(() => ProcessThread(queue)));
            }

            workerThreads.ForEach(_ => _.Start());

            string inputLine;
            long nEnqueued = 0;
            Console.Write("Ingesting reads (1 dot/1000000): ");
            while (null != (inputLine = inputFile.ReadLine()))
            {
                queue.Enqueue(inputLine);
                nEnqueued++;
                if (nEnqueued % 1000000 == 0)
                {
                    Console.Write(".");
                }
            }

            Console.WriteLine();

            queue.TerminateWriter();

            workerThreads.ForEach(_ => _.Join());



            outputFile.WriteLine(globalState.nUnmapped + " unmapped");
            outputFile.WriteLine("Distance\tCount");
            var counts = globalState.countByDistance.Select(_ => _.Key).ToList();
            counts.Sort();
            for (int i = 0; i < counts.Max(); i++)
            {
                if (globalState.countByDistance.ContainsKey(i))
                {
                    outputFile.WriteLine(i + "\t" + globalState.countByDistance[i]);
                } else
                {
                    outputFile.WriteLine(i + "\t0");
                }
            }
            if (globalState.unmatchedReads.Count() > 0)
            {
                outputFile.WriteLine("more\t" + globalState.unmatchedReads.Count());
            }

            outputFile.WriteLine("**done**");
            outputFile.Close();

            Console.WriteLine("Processed " + nEnqueued + " reads in " + ASETools.ElapsedTimeInSeconds(timer));
        } // Main
    } // Program 
} // namespace

